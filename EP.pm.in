# -*- perl -*-
#
#   HTML::EP	- A Perl based HTML extension.
#
#
#   Copyright (C) 1998    Jochen Wiedmann
#                         Am Eisteich 9
#                         72555 Metzingen
#                         Germany
#
#                         Phone: +49 7123 14887
#                         Email: joe@ispsoft.de
#
#   All rights reserved.
#
#   You may distribute this module under the terms of either
#   the GNU General Public License or the Artistic License, as
#   specified in the Perl README file.
#
############################################################################

require 5.004;
use strict;

require URI::Escape;
require HTML::Parser;
require CGI;
require Symbol;


package HTML::EP;

$HTML::EP::VERSION = '0.1002';
@HTML::EP::ISA = qw(HTML::Parser);


%HTML::EP::BUILTIN_METHODS = (
    'ep-comment' =>    { method => '_ep_comment',
			 default => 'comment',
		         always => 1 },
    'ep-package' =>    { method => '_ep_perl' },
    'ep-perl' =>       { method => '_ep_perl',
			 default => 'code' },
    'ep-errhandler' => { method => '_ep_errhandler',
			 default => 'template' },
    'ep-error' =>      { method => '_ep_error',
			 default => 'msg' },
    'ep-database' =>   { method => '_ep_database' },
    'ep-query' =>      { method => '_ep_query',
			 default => 'statement' },
    'ep-list' =>       { method => '_ep_list',
			 default => 'template' },
    'ep-input' =>      { method => '_ep_input' },
    'ep-if' =>         { method => '_ep_if',
			 default => 'result',
		         always => 1 },
    'ep-elseif' =>     { method => '_ep_elseif',
			 default => 'result',
			 condition => 1,
		         always => 1 },
    'ep-else' =>       { method => '_ep_elseif',
			 default => 'result',
			 condition => 0,
		         always => 1 },
    'ep-mail' =>       { method => '_ep_mail',
			 default => 'body' }
);


sub new ($) {
    my($proto) = @_;
    my $self = { _ep_stack => [],
		 _ep_funcs => { %HTML::EP::BUILTIN_METHODS },
		 _ep_output => '',
		 _ep_state => 1
	       };
    if (!($self->{cgi} = CGI->new())) {
	die "Cannot create CGI object: $!";
    }
    bless($self, (ref($proto) || $proto));
    $self;
}

sub ParseVar ($$$$) {
    my($self, $type, $var, $subvar) = @_;
    my $result;
    if ($var eq 'cgi') {
	$subvar =~ s/\-\>//;
	$var = $self->{cgi}->param($subvar);
    } else {
	$var = $self->{$var};
	while ($subvar  &&  $subvar =~ /^\-\>(\w+)(.*)/) {
	    my $v = $1;
	    $subvar = $2;
	    if ($v =~ /^\d+$/) {
		$var = $var->[$v];
	    } else {
		$var = $var->{$v};
	    }
	}
    }
    if (!defined($var)) { $var = ''; }
    if (!$type  ||  $type eq '&') {
	$var = HTML::Entities::encode($var);
    } elsif ($type eq '#') {
	$var = URI::Escape::uri_escape($var);
    } elsif ($type eq '~') {
	if (!$self->{dbh}) { die "Not connected"; }
	$var = $self->{dbh}->quote($var);
    }
    $var;
}

sub ParseVars ($$) {
    my($self, $str) = @_;
    $str =~ s/\$([\@\#\~]?)(\w+)((\-\>\w+)*)\$/$self->ParseVar($1, $2, $3)/eg;
    $str;
}

sub Run ($;$) {
    my($self, $template) = @_;
    if ($template) {
	$self->parse($template);
	$self->eof();
    } else {
	my $file = $ENV{PATH_TRANSLATED};
	if (!defined($file)) {
	    die "Missing server environment. (No PATH_TRANSLATED variable)";
	}
	my $fh = Symbol::gensym();
	if (!open($fh, "<$file")) {
	    die "Cannot open $file: $!";
	}
	$self->parse_file($fh);
	$self->eof();
    }
    $self->ParseVars($self->{_ep_output});
}


sub declaration ($$) {
    my($self, $decl) = @_;
    $self->{_ep_output} .= $decl;
}
*text = \&declaration;
sub comment ($$) {
    my($self, $msg) = @_;
    $self->{_ep_output} .= "<!--${msg}-->";
}

sub start ($$$$$) {
    my($self, $tag, $attr, $attrseq, $text) = @_;
    if ($tag =~ /^ep\-/) {
	my $func = $self->{_ep_funcs}->{$tag};
	if (!$func) {
	    die "No such function: $tag";
	}
	if (!$self->{_ep_state}  &&  !$func->{always}) {
	    return;
	}

	my($var, @parseList, @perlList);
	foreach $var (keys %$attr) {
	    if ($var =~ /^ep(parse|perl)-(.*)/) {
		my $type = $1;
		my $v = $2;
		if ($type eq 'parse') {
		    push(@parseList, $v);
		} else {
		    push(@perlList, $v);
		}
	    }
	}
	while (defined($var = shift @parseList)) {
	    $attr->{$var} = $self->ParseVars(delete $attr->{"epparse-$var"});
	}
	while (defined($var = shift @perlList)) {
	    my $str = delete $attr->{"epperl-$var"};
	    my $compartment = $self->{_ep_compartment};
	    if (!$compartment) {
		require Safe;
		$compartment = $self->{_ep_compartment} = Safe->new();
	    }
	    $@ = '';
	    $_ = $self;
	    $attr->{$var} = $compartment->reval($str);
	}

	my $method = $func->{method};
	my $state = $self->{_ep_state};
	if ($tag eq 'ep-if') {
	    undef $text;
	    $self->{_ep_state} = $attr->{eval}  &&  $state;
	    if ($self->{debug}) {
		print("ep-if: Eval = '",
		      (defined($attr->{eval}) ? $attr->{eval} : ''),
		      "' changing state to ",
		      ($self->{_ep_state} ? 1 : 0), "\n");
	    }
	} else {
	    $text = $self->$method($attr, $func);
	}
	if (!defined($text)) {
	    # Multiline mode
	    my $pop = { attr => $attr,
			tag => $tag,
			output => $self->{_ep_output},
			current => ($attr->{eval} ? 1 : 0),
			result => undef,
			state => $state
		      };
	    push(@{$self->{_ep_stack}}, $pop);
	    $self->{_ep_output} = '';
	    return;
	}
    }
    $self->{_ep_output} .= $text;
}

sub end ($$$) {
    my($self, $tag, $text) = @_;
    if ($tag =~ /^ep\-/) {
	my $func = $self->{_ep_funcs}->{$tag};
	if (!$func) {
	    die "No such function: $tag";
	}
	if (!$self->{_ep_state}  &&  !$func->{always}) {
	    return;
	}
	my $pop;
	if (!($pop = pop(@{$self->{_ep_stack}}))  ||  $pop->{tag} ne $tag) {
	    die "/$tag without $tag";
	}

	if ($tag eq 'ep-if') {
	    if ($pop->{current}) {
		$text = $self->{_ep_output};
	    } elsif (!defined($text = $pop->{result})) {
		$text = '';
	    }
	    $self->{_ep_output} = $pop->{output};
	} else {
	    my $method = $func->{method};
	    my $attr = $pop->{attr};
	    $attr->{$func->{default}} = $self->{_ep_output};
	    $self->{_ep_output} = $pop->{output};
	    $text = $self->$method($attr, $func);
	}
	$self->{_ep_output} .= $text;
	$self->{_ep_state} = $pop->{state};
    } elsif ($self->{_ep_state}) {
	$self->{_ep_output} .= $text;
    }
}


use vars qw($AUTOLOAD $AUTOLOADED_ROUTINES %AUTOLOADED_SUBS);
sub AUTOLOAD {
    my $func = $AUTOLOAD;
    $func =~ s/.*\:\://;
    if (!%AUTOLOADED_SUBS) {
	if ($AUTOLOADED_ROUTINES) {
	    %AUTOLOADED_SUBS = eval $AUTOLOADED_ROUTINES;
	} else {
	    die "No autoloadable methods defined.";
	}
    }
    if (exists($AUTOLOADED_SUBS{$func})) {
	eval $AUTOLOADED_SUBS{$func}; if ($@) { die $@; }
	goto &$func;
    }
    die "Method $func is not available.";
}


############################################################################
#
#   Autoloaded functions
#
############################################################################

$AUTOLOADED_ROUTINES = <<'END_OF_AUTOLOADED_ROUTINES';

(

_ep_comment => <<'end_of__ep_comment',
sub _ep_comment ($$;$) {
    my($self, $attr) = @_;
    if (!defined($attr->{comment})) {
	$self->{_ep_state} = 0;
	return undef;
    }
    ''
}
end_of__ep_comment


_ep_perl => <<'end_of__ep_perl',
sub _ep_perl ($$;$) {
    my($self, $attr) = @_;
    my $file = $attr->{src};
    my $code;
    if ($attr->{name}) {
	bless($self, $attr->{name});
	my $isa = $attr->{isa} || 'HTML::EP';
	no strict 'refs';
	@{$attr->{name} . "::ISA"} = split(/ /, $isa);
    }
    if ($file) {
	my $fh = Symbol::gensym();
	if (!open($fh, "<$file")) {
	    die "Cannot open $file: $!";
	}
	local($/) = undef;
	$code = <$fh>;
	if (!defined($fh)  ||  !close($fh)) {
	    die "Error while reading $file: $!";
	}
    } else {
	$code = $attr->{code};
	if (!defined($code)) {
	    return undef;
	}
    }
    my $output;
    if (!exists($attr->{package})) {
	my $compartment = $self->{_ep_compartment};
	if (!$compartment) {
	    require Safe;
	    $compartment = $self->{_ep_compartment} = Safe->new();
	}
	$@ = '';
	$_ = $self;
	$output = $compartment->reval($code);
    } else {
	$output = eval "package " . $attr->{package} . "; " . $code;
    }
    if ($@) { die $@ };
    if ($attr->{output}) {
	my $type = lc $attr->{output};
	if ($type eq 'html') {
	    $output = HTML::Entities::encode($output);
	} elsif ($type eq 'url') {
	    $output = URI::Escape::uri_escape($output);
	}
    }
    $output;
}
end_of__ep_perl


_ep_database => <<'end_of__ep_database',
sub _ep_database ($$;$) {
    my($self, $attr) = @_;
    my $dsn = $attr->{dsn} || $ENV{DBI_DSN};
    my $user = $attr->{user} || $ENV{DBI_USER};
    my $pass = $attr->{password} || $ENV{DBI_PASS};
    my $dbhvar = $attr->{dbh} || 'dbh';
    require DBI;
    if ($self->{debug}) {
	printf("Connecting to database: dsn = %s, user = %s, pass = %s\n",
	       $dsn, $user, $pass);
    }
    $self->{$dbhvar} = DBI->connect($dsn, $user, $pass, { RaiseError => 1 });
    '';
}
end_of__ep_database


_ep_query => <<'end_of__ep_query',
sub _ep_query ($$;$) {
    my($self, $attr) = @_;
    my $statement = $attr->{statement};
    if (!defined($statement)) {
	return undef;
    }
    my $dbh = $self->{$attr->{dbh} || 'dbh'};
    if (!$dbh) { die "Not connected"; }
    if ($self->{debug}) {
	print "Executing query, statement = $statement\n";
    }
    my $result = $attr->{result};
    if ($result) {
	my $sth = $dbh->prepare($statement);
	$sth->execute();
	my $list = [];
	my $ref;
	if ($attr->{resulttype}  &&  $attr->{resulttype} eq 'array') {
	    while ($ref = $sth->fetchrow_arrayref()) {
		push(@$list, [@$ref]);
	    }
	} else {
	    while ($ref = $sth->fetchrow_hashref()) {
		push(@$list, {%$ref});
	    }
	}
	$self->{$result} = $list;
	$self->{"${result}_rows"} = @$list;
	if ($self->{debug}) {
	    print "Result: ", scalar(@$list), " rows.\n";
	}
    } else {
	$dbh->do($statement);
    }
    '';
}
end_of__ep_query


_ep_list => <<'end_of__ep_list',
sub _ep_list ($$;$) {
    my($self, $attr) = @_;
    my $template;
    if (!defined($template = $attr->{template})) {
	return undef;
    }
    my $output = '';
    my $list = $self->{$attr->{items}};
    my $l = $attr->{item} or die "Missing item name";
    my $ref;
    foreach $ref (@$list) {
	$self->{$l} = $ref;
	$output .= $self->ParseVars($template);
    }
    $output;
}
end_of__ep_list


_ep_errhandler => <<'end_of__ep_errhandler',
sub _ep_errhandler ($$;$) {
    my($self, $attr) = @_;
    my $type = $attr->{type};
    $type = ($type  &&  (lc $type) eq 'user') ? 'user' : 'system';
    if ($attr->{src}) {
	$self->{'_ep_err_file_' . $type} = $attr->{src};
    } else {
	my $template = $attr->{template};
	if (!defined($template)) {
	    return undef;
	}
	$self->{'_ep_err_msg_' . $type} = ($attr->{template} || '');
    }
    '';
}
end_of__ep_errhandler


_ep_error => <<'end_of__ep_error',
sub _ep_error ($$;$) {
    my($self, $attr) = @_;
    my $msg = $attr->{msg};
    if (!defined($msg)) { return undef; }
    my $type = $attr->{type};
    $self->{_ep_err_type} = ($type  &&  (lc $type) eq 'user') ? 1 : 0;
    die $msg;
    '';
}
end_of__ep_error


_ep_input => <<'end_of__ep_input',
sub _ep_input ($$;$) {
    my($self, $attr) = @_;
    my $hash = {};
    my $prefix = $attr->{prefix};
    my $var;
    foreach $var ($self->{cgi}->param()) {
	if ($var =~ /^\Q$prefix\E(\w+?)_(.*)$/) {
	    my $col = $2;
	    my $type = $1;
	    $hash->{$col} = { col => $col,
			      type => $type,
			      val => $self->{cgi}->param($var)
			    };
	}
    }
    $self->{$attr->{dest}} = $hash;
    '';
}
end_of__ep_input


_ep_elseif => <<'end_of__ep_elseif',
sub _ep_elseif ($$;$) {
    my($self, $attr, $func) = @_;
    my $stack = $self->{_ep_stack};
    if (!@$stack) {
	die "elseif without if";
    }
    my $pop = $stack->[$#$stack];
    if ($pop->{tag} ne 'ep-if') {
	die "elseif without if";
    }
    if ($pop->{current}) {
	$pop->{result} = $self->{_ep_output};
	$pop->{current} = $self->{_ep_state} = 0;
    } elsif (!defined($pop->{result})) {
	$pop->{current} = !$func->{condition} || ($attr->{eval} ? 1 : 0);
	$self->{_ep_state} = $pop->{current} && $pop->{state};
	if ($self->{debug}) {
	    print($pop->{tag}, ": Eval = '",
		  (defined($attr->{eval}) ? $attr->{eval} : ''),
		  "' changing state to ",
		  ($self->{_ep_state} ? 1 : 0), "\n");
	}
    }
    $self->{_ep_output} = '';
}
end_of__ep_elseif


_ep_mail => <<'end_of__ep_mail',
sub _ep_mail ($$;$) {
    my($self, $attr, $func) = @_;
    my $body = delete $attr->{body};
    my $host = (delete $attr->{mailserver}) || '~mailhost~';
    if (!defined($body)) {
	return undef;
    }
    require Mail::Header;
    my $msg = new Mail::Header;
    my($header, $val);
    foreach $header ('to', 'from', 'subject') {
	if (!$attr->{$header}) {
	    die "Missing header attribute: $header";
	}
    }
    foreach $header ('to', 'cc', 'bcc') {
	if ($attr->{$header}) {
	    foreach $val (split (/,/, $attr->{$header})) {
		$msg->add($header, $val);
	    }
	    delete $attr->{$header};
	}
    }
    while (($header, $val) = each %$attr) {
	$msg->add($header, $val);
    }
    require Mail::Internet;
    my $mail = Mail::Internet->new([$self->ParseVars($body)], Header => $msg);
    $ENV{SMTPHOSTS} = $host;
    $mail->smtpsend();
    '';
}
end_of__ep_mail

);


END_OF_AUTOLOADED_ROUTINES

