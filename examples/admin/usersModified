#!/usr/bin/perl -w
#
#   Apply modifications from the user database.
#

use strict;
$ENV{'PATH'} = '/bin:/usr/bin:/sbin:/usr/sbin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
$) = $( = 0;
$> = $< = 0;

require Symbol;
require DBI;


############################################################################
#
#   Constant variables
#
############################################################################

my $PATH_PASSWD = "/etc/passwd";
my $PATH_ALIASES = "/etc/aliases";
my $PATH_NEWALIASES = "/usr/bin/newaliases";

my $DBI_DSN = 'DBI:mysql:user';
my $DBI_USER = 'nobody';
#my $DBI_PASS = 'my_name_is_nobody';
my $DBI_PASS = '';

my $ALIAS_START =
    "# Automatically generated by /usr/local/bin/usersModified";
my $ALIAS_END =
    "# End of automatically generated by /usr/local/bin/usersModified";


############################################################################
#
#   Name:    ReadUserListFromFile
#
#   Purpose: Read list of existing users from file.
#
#   Inputs:  Nothing
#
#   Returns: Hash ref of users
#
############################################################################

sub ReadUserListFromFile {
    my %users;
    if (-f $PATH_PASSWD) {
	my $fh = Symbol::gensym();
	if (!open($fh, "<$PATH_PASSWD")) {
	    die "Cannot open $PATH_PASSWD: $!";
	}
	while (defined(my $line = <$fh>)) {
	    chomp $line;
	    my($user, $passwd, $uid, $gid, $realname, $homedir, $shell) =
		split(/:/, $line);
	    if ($uid > 599  &&  $uid < 60000) {
		$users{$user} = {
		    'USER' => $user,
		    'PASSWORD' => $passwd,
		    'UID' => $uid,
		    'GID' => $gid,
		    'REALNAME' => $realname,
		    'HOMEDIR' => $homedir,
		    'SHELL' => $shell
		    };
	    }
	}
    }
    \%users;
}


############################################################################
#
#   Name:    ReadUserListFromDB
#
#   Purpose: Read list of current users from database.
#
#   Inputs:  Nothing
#   Returns: Hash ref of users
#
############################################################################

sub ReadUserListFromDB {
    my %users;
    my %groups;
    my $dbh = DBI->connect($DBI_DSN, $DBI_USER, $DBI_PASS,
			   { 'PrintError' => 1, 'RaiseError' => 1,
			     'Warn' => 1 });

    my $sth = $dbh->prepare("SELECT * FROM USERS");
    $sth->execute();
    while (my $ref = $sth->fetchrow_hashref()) {
	$users{$ref->{'USER'}} = $ref;
    }
    $sth->finish();

    $sth = $dbh->prepare("SELECT * FROM GROUPS");
    $sth->execute();
    while (my $ref = $sth->fetchrow_arrayref()) {
	if (!exists($groups{$ref->[0]})) {
	    $groups{$ref->[0]} = [];
	}
	push(@{$groups{$ref->[0]}}, $ref->[1]);
    }
    $sth->finish();

    $dbh->disconnect();
    (\%users, \%groups);
}

############################################################################
#
#   Name:    UpdateEtcPasswd
#
#   Purpose: Updates the user list in /etc/passwd
#
#   Inputs:  $users_file - Hash ref of current users in /etc/passwd, only
#                users of UID's between 600 and 60000 must appear!
#            $users_db - Hash ref of current users in database
#
#   Returns: Nothing
#
############################################################################

sub UpdateEtcPasswd {
    my($users_file, $users_db) = @_;
    my(@deleted_users);
    my(%done_users);

    # First step: Verify for modifications of currently existing users
    foreach my $uf (values (%$users_file)) {
	if (!exists($users_db->{$uf->{'USER'}})) {
	    push(@deleted_users, $uf->{'USER'});
	    next;
	}
	my $udb = $users_db->{$uf->{'USER'}};
	if ($uf->{'UID'} ne $udb->{'UID'}) {
	    printf STDERR ("Warning: Cannot update UID of user %s\n.",
			   $uf->{'USER'});
	}
	if ($uf->{'HOMEDIR'} ne $udb->{'HOMEDIR'}) {
	    printf STDERR ("Warning: Cannot update home directory of user"
			   . " %s.\n",, $uf->{'USER'});
	}
	if ($uf->{'REALNAME'} ne $udb->{'REALNAME'}) {
	    printf("Changing real name of user %s:\n", $udb->{'USER'});
	    Command("chfn", "-f", $udb->{'REALNAME'}, $udb->{'USER'});
	}
	if ($uf->{'SHELL'} ne $udb->{'SHELL'}) {
	    printf("Changing shell of user %s:\n", $udb->{'USER'});
	    Command("chsh", "-s", $udb->{'SHELL'}, $udb->{'USER'});
	}
	{
	    my $pwd = $uf->{'PASSWORD'};
	    my $salt = substr($pwd, 0, 2);
	    if (crypt($udb->{'PASSWORD'}, $salt) ne $pwd) {
		printf("Changing password of user %s:\n", $udb->{'USER'});
		SCommand("echo '%s:%s' | chpasswd",
			 $udb->{'USER'}, $udb->{'PASSWORD'});
	    }
	}
	$done_users{$uf->{'USER'}} = 1;
    }

    # Second step: Delete users we no longer need
    foreach my $user (@deleted_users) {
	printf("Deleting user %s\n", $user);
	Command("userdel",  $user);
    }

    # Third step: Create any new users
    foreach my $user (values(%$users_db)) {
	if ($done_users{$user->{'USER'}}) {
	    next;
	}
	printf("Creating user %s\n", $user->{'USER'});
	Command("useradd", "-c", $user->{'REALNAME'},
		"-d", $user->{'HOMEDIR'}, "-u", $user->{'UID'},
		"-s", $user->{'SHELL'},
		$user->{'USER'});
	printf("Changing password of user %s:\n", $user->{'USER'});
	SCommand("echo '%s:%s' | chpasswd",
		 $user->{'USER'}, $user->{'PASSWORD'});
    }
}


############################################################################
#
#   Name:    UpdateEtcAliases
#
#   Purpose: Updates /etc/aliases
#
#   Inputs:  $user_db - Hash ref of users currently in database
#
#   Returns: Nothing
#
############################################################################

sub UpdateEtcAliases ($$) {
    my $user_db = shift; my $groups = shift;

    my $db_aliases = '';
    foreach my $user (values(%$user_db)) {
	foreach my $alias (split(/,/, $user->{'ALIASES'})) {
	    $alias =~ s/^\s+//;
	    $alias =~ s/\s+$//;
	    if ($alias  &&  (lc $alias) ne (lc $user->{'USER'})) {
		$db_aliases .= sprintf("%s: %s\n", $alias, $user->{'USER'});
	    }
	}
	if ($user->{'FORWARD'}) {
	    $db_aliases .= sprintf("%s: %s\n", $user->{'USER'},
				   $user->{'FORWARD'});
	}
    }
    foreach my $group (keys(%$groups)) {
	$db_aliases .= sprintf("%s: %s\n",
			       $group, join(",", @{$groups->{$group}}));
    }

    my $alias_file;
    my $fh = Symbol::gensym();
    {
	local $/ = undef;
	if (!open($fh, "<$PATH_ALIASES")  ||
	    !defined($alias_file = <$fh>)  ||
	    !close($fh)) {
	    die "Error while reading $PATH_ALIASES: $!";
	}
    }

    $alias_file =~ s/\Q$ALIAS_START\E\n.*\Q$ALIAS_END\E\n//s;
    $alias_file .= "$ALIAS_START\n$db_aliases$ALIAS_END\n";

    require IO::AtomicFile;
    if (!($fh = IO::AtomicFile->new($PATH_ALIASES, "w"))  ||
	!$fh->print($alias_file)  ||  !$fh->close()) {
	printf STDERR (<<'END_OF_MESSAGE', $PATH_ALIASES, $!);

An error occurred while writing the file %s: $!

This can be fatal for the email system, please take immediate action!

END_OF_MESSAGE
        exit(1);
    }

    Command($PATH_NEWALIASES);
}


############################################################################
#
#   Name:    Command
#
#   Purpose: Issue a shell command
#
#   Inputs:  Command line arguments
#
#   Returns: Nothing
#
############################################################################

sub SCommand {
    my $fmt = shift;
    my @args = map { my $c = $_; $c =~ s/([^a-zA-Z0-9_\/\-])/\\$1/g; $c } @_;
    Command(sprintf($fmt, @args));
}
sub Command {
    print ("Executing command: ", join(" ", @_), "\n");
    system @_;
}

############################################################################
#
#   This is main().
#
############################################################################

{
    my $users_file = ReadUserListFromFile();
    my($users_db, $groups) = ReadUserListFromDB();
    UpdateEtcPasswd($users_file, $users_db);
    UpdateEtcAliases($users_db, $groups);
}
